<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.16-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> sig &middot; sig </title>

  
  <link rel="stylesheet" href="https://sigmonsays.github.io/css/poole.css">
  <link rel="stylesheet" href="https://sigmonsays.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://sigmonsays.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://sigmonsays.github.io/index.xml" rel="alternate" type="application/rss+xml" title="sig" />
</head>

<body class="">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://sigmonsays.github.io/"><h1>sig</h1></a>
      <p class="lead">
       tech, life and random 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/about/"> About </a></li>
      
        <li><a href="/archive/"> Archive </a></li>
      
        <li><a href="/contact/"> Contact </a></li>
      
        <li><a href="https://github.com/sigmonsays"> Github </a></li>
      
        <li><a href="/keybase/"> PGP </a></li>
      
        <li><a href="/projects/"> Projects </a></li>
      
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://sigmonsays.github.io/pinterest-sucks/">
        Pinterest invades google
      </a>
    </h1>

    <span class="post-date">Sun, Mar 18, 2018</span>


    

<p>Pinterest is awful.</p>

<p>This has been growing for years. Here is the typical situation I think more people run into than you think. When you are looking for an image
on google image search and find what you are looking for by thumbnail, and click through just to be taken to pinterest.com. Once you land here,
you do not see any fragment of what you came for. Instead, you are confronted with a sign up page.</p>

<p>This has happened so many times to me and ive ranted to my friends about it before. However, It happened again recently and I also happened to read about it
later. So I am taking it upon myself to make this post, hopefully as a way to contribute to a small change: Pinterest not sucking.</p>

<p><code>Pinterest Sucks</code></p>

<p>They require you to sign up for accounts to see any content yet manage to infect the SEO system of google search results. Both regular
results are affected but also image search.</p>

<p>Even after logging into Pinterest, the image does not show. They are nothing more than click bait.</p>

<p>They probably dont realize it but their decision is probably costing them accounts. I will never sign up for a pinterest account because of the terrible
user experience.</p>

<p>I can never find what im looking for. There is never a working link back to the original source.  Everything they do is garbage. They are the next generation
spammer.</p>

<p>If you want ideas on coffee tables and want to look at a bunch of photos for ideas, they fit. However getting anything meaningful out of pinterest via search
is an exercise in futility.</p>

<p><code>Pinterest is a broken model</code></p>

<blockquote>
<p>Its not just that Pinterest is spamming google searches, and that you have to search again once you get to Pinterest (assuming you have an account and are logged in).
Its also the fact that the majority of Pins are BROKEN- they dont lead back to the original source. (Whether because the pins are old, content has been moved, etc.)
So as opposed to a search engine like Google that continuously updates its index, the Pinterest model will only lead to more and more broken links as time goes by.
It is a broken model, and incredibly frustrating.</p>
</blockquote>

<p><code>What can we do?</code></p>

<ol>
<li><p>Stop using pinterest and help others to stop using pinterest.</p></li>

<li><p>Complain. Write blog posts, like this.</p></li>

<li><p>Use an extension to block their results</p></li>

<li><p>Chrome <a href="https://chrome.google.com/webstore/detail/personal-blocklist-by-goo/nolijncfnkgaikbjbdaogikpmpbdcdef?hl=en">https://chrome.google.com/webstore/detail/personal-blocklist-by-goo/nolijncfnkgaikbjbdaogikpmpbdcdef?hl=en</a></p></li>

<li><p>Firefox <a href="https://github.com/wildskyf/personal-blocklist">https://github.com/wildskyf/personal-blocklist</a></p></li>
</ol>

<h1 id="references:e809b07ecd33fccb59a427cc6c8c434a">References</h1>

<ul>
<li>[1] <a href="https://www.reddit.com/r/google/comments/85atho/pinterest_needs_to_be_removed_from_google_imo/">reddit thread mar18 2018</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://sigmonsays.github.io/2017/11/why-use-the-go-programming-language/">
        why use the go programming language?
      </a>
    </h1>

    <span class="post-date">Thu, Nov 16, 2017</span>


    

<p>I have been a go programmer before go 1.0 was released, I think that brings me back to beginning writing go code around 2011. as en exercise I wrote a simple daemon to handle
some backend work where concurrency was key and have enjoyed developing it for quite some time. It replaced a python process where many actors
needed to operate on a workqueue. This daemon is actually still in produciton today =P</p>

<h1 id="in-summary:2948febad6b536d231a5b814f2926696">In summary</h1>

<ul>
<li><a href="#compiled-language:2948febad6b536d231a5b814f2926696">Compiled Language</a> has a compiler which checks a lot of errors for me</li>
<li><a href="#strictly-typed:2948febad6b536d231a5b814f2926696">Strictly typed</a> language</li>
<li><a href="#static-linking:2948febad6b536d231a5b814f2926696">Statically linked</a> binary (single binary deployment!)</li>
<li><a href="#type-system:2948febad6b536d231a5b814f2926696">Unique type system</a> using interfaces, composition and embedding instead of OOP patterns</li>
<li><a href="#language-grammer:2948febad6b536d231a5b814f2926696">Language Grammer</a> well defined</li>
<li><a href="#tooling:2948febad6b536d231a5b814f2926696">Amazing Tooling</a> ie, gofmt, godef, go-imports, vim-go</li>
<li>small standard library and the go1 promise <a href="https://golang.org/doc/go1compat">https://golang.org/doc/go1compat</a></li>
<li><a href="#concurrency:2948febad6b536d231a5b814f2926696">concurrency</a> is a language (not library) feature, ie concurrency, goroutines, and channels</li>
<li>it is good to collaborate on (e.g. writing large systems)</li>
</ul>

<h1 id="work-in-progress:2948febad6b536d231a5b814f2926696">work in progress!</h1>

<p>This page will be filled out over time</p>

<h1 id="compiled-language:2948febad6b536d231a5b814f2926696">Compiled Language</h1>

<p>compiler checks a lot of errors for me</p>

<p>One case which use to get me all the time is error handling code in dynamic languages. If you do not unit test every case, often a undefined variable would result
in your error handling code explode.</p>

<p>The go language also has some unique features. Undefined and unused variables cause compiler errors.</p>

<h1 id="strictly-typed:2948febad6b536d231a5b814f2926696">Strictly typed</h1>

<p>Similar to being a compiled language,</p>

<p>Large refactors in code often require changing arguments around or adding new ones. With a strictly
typed language this is easy. If the compile works, you can be fairly confident that everything will run
as designed.</p>

<h1 id="static-linking:2948febad6b536d231a5b814f2926696">Static linking</h1>

<p>Being a statically linked package means you are deploying a single binary or binary + config file. The only thing most go binaries link to are libc for some OS level networking support. It is possible
to compile without libc entirely if you choose. Finally, if you avoid <strong>cgo</strong> this means your binary will run anywhere given you have a matching architecture.</p>

<p><strong>This is an amazing feature coming from python</strong> I love python but its biggest shortcoming is the confusion that arrises from the myraid of packaging systems.</p>

<h1 id="type-system:2948febad6b536d231a5b814f2926696">Type system</h1>

<p>Go has a interesting type system which removes the fundamentally flawed OOP features. OOP programmers often uses inheritenace when composition could be used instead.</p>

<p><strong>composition</strong> means you combine objects together instead of searching a inheritence tree. I am not going into all the details here but here is the <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">wikipedia article on composition</a></p>

<h1 id="language-grammer:2948febad6b536d231a5b814f2926696">Language Grammer</h1>

<p>a language spec that is well defined <a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>, short, and simple.</p>

<p>Without a well defined language specification, none of the tooling would be possible. It also makes it easy to develop tools which parse code into AST (Abstract syntax tree) and manipulate it. Ie, write code which
modifies other code. This was not very practical in other langauges (IMHO). The <code>go/ast</code> and <code>go/types</code> packages lowered the barrier of entry to write quick tools for manipulating go source code.</p>

<h1 id="tooling:2948febad6b536d231a5b814f2926696">Tooling</h1>

<p>The amount of tooling really makes go a step above the rest</p>

<p><code>gofmt</code></p>

<p>This tool automatically formats source code in a pre-defined way.</p>

<p>The tool shuts down the bike shed discussions which naturally occur about code formatting. Most people (if not all) require <code>gofmt</code> to be executed on the source code being submitted to a project. This
is also very useful to tie into your editor on save. Often you can paste a piece of code which does not match the indentation level, and watch it all fall into place.</p>

<p>I have spent a lot of time re-indenting code and this is no longer a step in go.</p>

<p><code>goimports</code></p>

<p>This tool automatically adds imports and removes unused imports in a source file</p>

<p>It is very useful to not worry about jumping to the top of the file and change imports every time you modify code.</p>

<p><code>godef</code></p>

<p>This tool is used in editors to jump to a types declartion.</p>

<p>Within vim one can type <code>gd</code> on any variable or type and the editor jumps to the file and location where that <em>thing</em> is defined. It is very useful for navigating
unfamiliar and large source trees.</p>

<p><code>gocode</code></p>

<p>This tool provides a auto complete interface of methods and variables</p>

<p>integration with editors, like <strong>vim-go</strong> really tie the tools together for a IDE like developer experience from the terminal. Of course there
is a lot of graphical editors too if that is your thing.</p>

<p><strong>Others?</strong></p>

<p>I am sure I missed some tools that I use.  What tools do you use that are not mentioned here?</p>

<h1 id="concurrency:2948febad6b536d231a5b814f2926696">Concurrency</h1>

<p>Last but not least and quite possibly the most important feature of go is its concurrency primitives.</p>

<p>They are built directly into the language specification and first class citizens (they are not bolted on later).</p>

<p><code>goroutines</code> are essentially coroutines but are executed across multiple real OS threads. The runtime scheduler handles everything for you so you can focus on writing logically blocking
code. goroutines run in parallel, which makes it easy to maintain a mental model of what is happening in a concurrent program.</p>

<p><code>channels</code> are the communication primitive and allow different goroutines to talk to each other. A channel can be buffered and unbuffered, which allows creation of some really useful patterns.</p>

<h1 id="useful-resources:2948febad6b536d231a5b814f2926696">Useful Resources</h1>

<ul>
<li>Go Proverbs - Bunch of wisdom - <a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a></li>
<li>Errors are Values - <a href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://sigmonsays.github.io/2016/03/programming-exercise/">
        programming exercise
      </a>
    </h1>

    <span class="post-date">Wed, Mar 2, 2016</span>


    <p>I heard from a friend about an interesting interview question that I thought would be easy.</p>

<p><em>The problem</em></p>

<p>the goal of this program is to find the shortest number of stickers used to make a another word given that you have thousands of stickers</p>

<p>for instance, with the word &ldquo;WPENGINE&rdquo; printed on them to make for example &ldquo;WWW&rdquo; would take 3 and another example is &ldquo;WINE&rdquo; would take 1.</p>

<p>The programs logic is really quite literal and was enjoyable to write.</p>

<p>We have a Sticker type who keeps track of the number of letters used and a pile of stickers which is just a list
of stickers. We search the pile for a given letter, and if its not found we add another sticker to the pile.</p>

<p>We keep a dummy sticker object around to validate that we do infact have the letters, and error if not.</p>

<p>The code</p>

<pre><code>  package main

  import (
     &quot;fmt&quot;
     &quot;os&quot;
     &quot;strings&quot;
  )

  func NewSticker(word string) *Sticker {
     s := &amp;Sticker{
        letters: make(map[rune]int, 0),
     }
     var v int
     for _, w := range strings.ToLower(word) {
        v, _ = s.letters[w]
        v += 1
        s.letters[w] = v
     }
     return s
  }

  type Sticker struct {
     letters map[rune]int
  }

  func (s *Sticker) HasLetter(l rune) bool {
     count, found := s.letters[l]
     if found == false {
        return false
     }
     if count &gt; 0 {
        return true
     }
     return false
  }

  func (s *Sticker) Desc() string {
     a := make([]string, 0)
     for l, cnt := range s.letters {
        a = append(a, fmt.Sprintf(&quot;%s=%d&quot;, string(l), cnt))
     }
     return strings.Join(a, &quot; &quot;)
  }

  func (s *Sticker) UseLetter(l rune) error {

     fmt.Printf(&quot;using letter %s\n&quot;, string(l))

     count, found := s.letters[l]
     if found == false {
        return fmt.Errorf(&quot;sticker doesn't have letter %s&quot;, l)
     }

     if count == 0 {
        return fmt.Errorf(&quot;letter is used up&quot;)
     }

     count--
     s.letters[l] = count
     return nil

  }

  type Pile struct {
     word     string
     stickers []*Sticker
  }

  func NewPile(word string) *Pile {
     p := &amp;Pile{
        word:     word,
        stickers: make([]*Sticker, 0),
     }
     return p
  }

  func (p *Pile) HasLetter(l rune) bool {
     for _, sticker := range p.stickers {
        if sticker.HasLetter(l) {
           return true
        }
     }
     return false
  }

  func (p *Pile) AddSticker() {
     p.stickers = append(p.stickers, NewSticker(p.word))
  }

  func main() {

     var err error
     sticker_word := &quot;WPENGINE&quot;

     word := &quot;pingping&quot;
     if len(os.Args) &gt; 1 {
        word = os.Args[1]
     }
     fmt.Printf(&quot;sticker word %s\n&quot;, sticker_word)
     fmt.Printf(&quot;making word %s\n&quot;, word)
     pile := NewPile(sticker_word)

     // just to validate we have the letters..
     sticker := NewSticker(sticker_word)

     for _, l := range word {
        //s := string(l)
        fmt.Printf(&quot;letter %s\n&quot;, string(l))

        if sticker.HasLetter(l) == false {
           err = fmt.Errorf(&quot;no letter %s&quot;, string(l))
           break
        }

        if pile.HasLetter(l) == false {
           pile.AddSticker()
        }

        // find a sticker that has the letter we're lookin for in the pile
        for _, sticker := range pile.stickers {
           if sticker.HasLetter(l) {
              sticker.UseLetter(l)
              continue
           }
        }

     }

     if err != nil {
        fmt.Printf(&quot;ERROR: %s\n&quot;, err)
        return
     }

     // print the results

     used := len(pile.stickers)
     fmt.Printf(&quot;stickers used %d\n&quot;, used)

     for i, sticker := range pile.stickers {
        fmt.Printf(&quot;sticker #%d  letters %+v\n&quot;, i+1, sticker.Desc())
     }

  }
</code></pre>

  </div>
  
</div>
</div>

  </body>
</html>
