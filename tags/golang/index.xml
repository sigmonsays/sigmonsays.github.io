<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on sig</title>
    <link>http://sigmonsays.github.io/tags/golang/</link>
    <description>Recent content in Golang on sig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 16 Nov 2017 10:27:27 -0800</lastBuildDate>
    <atom:link href="http://sigmonsays.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>why use the go programming language?</title>
      <link>http://sigmonsays.github.io/2017/11/why-use-the-go-programming-language/</link>
      <pubDate>Thu, 16 Nov 2017 10:27:27 -0800</pubDate>
      
      <guid>http://sigmonsays.github.io/2017/11/why-use-the-go-programming-language/</guid>
      <description>

&lt;h1 id=&#34;in-summary:2948febad6b536d231a5b814f2926696&#34;&gt;In summary&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;compiled language has a compiler which checks a lot of errors for me&lt;/li&gt;
&lt;li&gt;statically compiled (single binary deployment!)&lt;/li&gt;
&lt;li&gt;strictly typed language&lt;/li&gt;
&lt;li&gt;excellent type system and OOP-like features (interfaces)

&lt;ul&gt;
&lt;li&gt;composition and embedding&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;language grammer well defined&lt;/li&gt;
&lt;li&gt;language spec well defined &lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;https://golang.org/ref/spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;amazing tooling (gofmt, godef, vim-go)&lt;/li&gt;
&lt;li&gt;small standard library and the go1 promise &lt;a href=&#34;https://golang.org/doc/go1compat&#34;&gt;https://golang.org/doc/go1compat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;concurrency is a language (not library) feature&lt;/li&gt;
&lt;li&gt;concurrency, goroutines, channels&lt;/li&gt;
&lt;li&gt;it is good to collaborate on (e.g. writing large systems)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;compiled-language:2948febad6b536d231a5b814f2926696&#34;&gt;compiled language&lt;/h1&gt;

&lt;p&gt;compiled checks a lot of errors for me&lt;/p&gt;

&lt;p&gt;Large refactors in code often require changing arguments around or adding new ones. With a strictly
typed language this is easy. If the compile works, you can be fairly confident that everything will run
as designed.&lt;/p&gt;

&lt;h1 id=&#34;work-in-progress:2948febad6b536d231a5b814f2926696&#34;&gt;work in progress&lt;/h1&gt;

&lt;p&gt;This page will be filled out over time&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git-watch</title>
      <link>http://sigmonsays.github.io/2016/01/git-watch/</link>
      <pubDate>Sun, 03 Jan 2016 21:33:07 -0800</pubDate>
      
      <guid>http://sigmonsays.github.io/2016/01/git-watch/</guid>
      <description>&lt;p&gt;git watch is a simple library and CLI tool for monitoring git repositories and triggering events (restart process) when they change.&lt;/p&gt;

&lt;p&gt;git watch [1] was designed as a way to easily build and deploy daemons in development when upstream changes. The changes can be either
code (in git) or configuration.&lt;/p&gt;

&lt;p&gt;So here is a simple example which will automatically rebuild and restart a application when you git push (&lt;a href=&#34;https://github.com/sigmonsays/git-watch/tree/master/examples/go&#34;&gt;https://github.com/sigmonsays/git-watch/tree/master/examples/go&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Below in git-watch.yaml we check the upstream every 5 seconds and merge the master branch in. execcmd is &amp;ldquo;my_application&amp;rdquo; which is a simple application. When a upstream
change is detected, we invoke the updatecmd. If the updatecmd does not succeed, the restart process is aborted. Assuming the update command succeeds, we then invoke the install
command. After the install command succeeds, the application is restarted.&lt;/p&gt;

&lt;p&gt;git-watch.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # reinstall a go application when changes are detected in a git remote
  checkinterval: 5
  localbranch: master
  execcmd: my_application
  updatecmd: make
  install: make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  REPO=github.com/sigmonsays/git-watch

  all:
     go get -u $(REPO)/examples/go/my_application/...

  install:
     go install $(REPO)/examples/go/my_application
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Full usage&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Usage of git-watch:
 -branch string
       local branch (default &amp;quot;master&amp;quot;)
 -check int
       git check interval (seconds) (default 5)
 -config string
       git watch config (default &amp;quot;git-watch.yaml&amp;quot;)
 -dir string
       change directory before starting (default &amp;quot;.&amp;quot;)
 -exec-cmd string
       exec command (default &amp;quot;make run&amp;quot;)
 -http string
       start a http server
 -inherit-env
       inherit environment
 -inotify-dir string
       use inotify as a trigger in directory
 -install-cmd string
       install command (default &amp;quot;make install&amp;quot;)
 -loglevel string
       set log level (default &amp;quot;error&amp;quot;)
 -once
       run once and exit
 -static-dir string
       static directory (default &amp;quot;static&amp;quot;)
 -update-cmd string
       update command (default &amp;quot;make&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[1] - &lt;a href=&#34;https://github.com/sigmonsays/git-watch&#34;&gt;https://github.com/sigmonsays/git-watch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>